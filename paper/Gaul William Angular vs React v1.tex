\documentclass[12pt,letterpaper]{article}

% Import settings, which are stored in a separate file for convenience
\input{settings.tex}

% Set title
\title{\textbf{Angular vs. React}}
\author{William Gaul\\{ICS 419: Prof. Streveler}}
\date{\today}


\begin{document}
\maketitle

\begin{singlespace*}
\begin{abstract}
	% @TODO: Rewrite when paper is done
	The modern web is inherently dynamic. As the Internet has evolved -- as JavaScript plays an increasingly ubiquitous role and applications grow in size and complexity -- developers have turned ever more toward web frameworks to make sense of the chaos. Many companies now favor applicants who have experience working with these frameworks, and so a good understanding of their usage and purpose is crucial. Why do they exist? What problems do they purport to solve, if any? How will they benefit developers and end users alike? This project aims to answer these questions by examining two very popular web frameworks in more detail: Angular and React.
\end{abstract}
\end{singlespace*}


\section{The Web, Then and Now}
\vspace{-12pt}

\begin{quote}
	\singlespacing
	\emph{In which a number of problems caused by the evolution of the web, and motivating the creation of web frameworks, is discussed.}
\end{quote}

The web then was, as many might now say, boring.

Tim Berners-Lee, the father of the web, introduced HTML in 1989 as an easy way to produce and disseminate information across the fledgling scientific community called the Internet. HTML encapsulated the notion of documents described by something called hypertext: rich content that contains \emph{hyperlinks} pointing to other documents. From the start, HTML was ``intended for simple document structure, not for handling today's varied and complex information needs'' \cite[p.~9]{Sklar:2012} -- that is, static web pages \cite{Schlensker:2014}.

By the mid-1990s, the web began to gain widespread popularity, causing companies and individuals alike to focus on developing a web presence. This, coupled with the lack of authoritative standards, led to an explosion of questionable online design practices \footnote{As an example, HTML tables were once used for entire page layouts although they are only meant for tabulating data, simply because they are easier to work with.}. Problems with interoperability were only exacerbated by the introduction of CSS and JavaScript. Although these new technologies were meant to simplify development by separating aesthetic and functional concerns from HTML content, they paved the way for greater complexity through manipulation of HTML elements \cite{Sklar:2012}.

The desire for more data-driven applications ushered in an era commonly known as ``Web 2.0,'' characterized by Dynamic HTML (DHTML) and rudimentary animated interactivity. At around this time, developers also began to feel the pangs of cross-platform development, as major browser vendors each tried to implement their own version of the HTML specification. These difficulties would only mount as Internet-capable mobile devices made their debut, forcing many designers to adapt existing sites for mobile-friendly consumption. \cite{Schlensker:2014}.

Fast-forward to the present: static, document-based web pages have largely been replaced by dynamic single-page applications (SPAs). JavaScript is a mature language with a strong community, and coupled with the recent release of CSS3, forms the cornerstone of the HTML5 specification that ``attempts to address \ldots the needs of modern Web design and the application-based future of the Web.'' \cite[p.~14]{Sklar:2012}. Development is no longer simply about cultivating a web presence -- rather, there is a distinct culture of \emph{integration} with existing services such as Twitter, Disqus, and GitHub.

What problems has this evolution caused? As applications continue to grow in complexity and scale, their architectures become increasingly difficult to reason about. With such weak standardization across the Internet, a great deal of code and logic is needlessly reimplemented \cite{Schlensker:2014}. Perhaps most troubling, however, is that HTML is \emph{still not designed for dynamic applications}, causing an ``impedance mismatch'' between what developers want to do and what web platforms are capable of supporting \cite{Angular:Docs, Hunt:2014}.



Fortunately, a solution exists: web frameworks.



% a library - a collection of functions which are useful when writing web apps. Your code is in charge and it calls into the library when it sees fit. E.g., jQuery.
% frameworks - a particular implementation of a web application, where your code fills in the details. The framework is in charge and it calls into your code when it needs something app specific. E.g., durandal, ember, etc.



%  \cite{Schlensker:2014}
%  \cite{Angular:Docs}			https://docs.angularjs.org/guide/introduction
%  \cite{Hunt:2013}				http://facebook.github.io/react/blog/2013/06/05/why-react.html
%  \cite{Green:2013}
%  \cite{Hunt:2014}
%  \cite{Sklar:2012}			http://books.google.com/books?id=1cgIAAAAQBAJ&pg=PA8&dq=how+the+web+has+evolved&hl=en&sa=X&ei=_wBjVKOjBcvooATrq4GwBg&ved=0CCQQ6AEwAQ#v=onepage&q=how%20the%20web%20has%20evolved&f=false


\section{Hello Dynamic World}
\vspace{-12pt}

\begin{quote}
	\singlespacing
	\emph{In which the author uses a simple dynamic web page to investigate the designs of Angular and React.}
\end{quote}

To gain a better understanding of how frameworks improve upon pure JavaScript, it is necessary to consider a simple example -- in this case, the web page shown in Figure \ref{fig:Example}.

\begin{SCfigure}[][h]
	\centering
	\caption{A simple example of a dynamic web element: the header text changes based on user input. Code for this example in pure JavaScript, as well as using the Angular and React frameworks, can be found in Appendix \ref{app:code}.}
	\fbox{\includegraphics[width=0.5\textwidth]{hello-world.png}}
	\label{fig:Example}
\end{SCfigure}

Syncing the contents of an \texttt{<h1>} element to an input is fairly straightforward with pure JavaScript: attach an \emph{event listener} to the input, and update the header's \texttt{innerHTML} accordingly whenever an event is fired. The problem with this approach is that it does not scale well. Imagine having to handle the updates of several thousand UI elements, a typical number for a web application as complex as Facebook. This pattern would have to be duplicated thousands of times, and the codebase would quickly become unmanageable.

In contrast, the Angular code contains no such low-level event handling. Rather, a JavaScript variable is introduced into the application's scope and bound to both the input and header \footnote{The variable, \texttt{\$scope.subject}, is specified as the input's \emph{model} via the \texttt{ng-model} attribute and the header's content via an inline template.}. This concept is known as \emph{two-way data binding} because updates may flow in both directions; when a user modifies the input its underlying model (the variable) is updated, and similarly when the variable is modified via JavaScript its new value will be reflected in the UI \cite{Angular:Docs}. The resulting code is highly declarative in nature, and moreover very terse, as nearly all of the low-level logic is handled by Angular behind the scenes.

React takes a different tack by removing HTML from the picture entirely. In its place are React components that encapsulate state and business logic, and that may be nested to construct complex applications. Updates are handled by describing the UI as it should appear at any discrete moment in time within the \texttt{render/0} function -- whenever the state of a component changes, it is automatically ``re-rendered'' \footnote{Here the markup for the input depends upon \texttt{this.state.subject}. Whenever the input is changed, \texttt{this.setState/1} is triggered with the new value, and the UI is rendered again.}. Because events from the user must still be handled manually, this is known as \emph{one-way data binding} \cite{Hunt:2014}.




One-way versus two-way data binding may seem like a simple distinction, but it has profound implications for how an application is designed, developed, and even reasoned about.


% On the one hand, Angular offers an expressive extension of HTML specifically designed for dynamic views, centered on a concept called “two-way data binding.”

% On the other hand, React uses a component system that makes it easy to reason about application architecture, powered by “one-way data binding.”


% "Angular was built with the CRUD application in mind." (DOCS)


% https://docs.angularjs.org/guide/databinding





\section{The Future is Reactive}
\vspace{-12pt}

\begin{quote}
	\singlespacing
	\emph{In which it is suggested that the functional and asynchronous paradigms uncovered by React will drive web design for the foreseeable future.}
\end{quote}




\section{Conclusion}
\vspace{-12pt}

\begin{quote}
	\singlespacing
	\emph{In which the points are tallied and a champion is crowned.}
\end{quote}



%It is hoped that this project will inspire any budding web developers in the class to embrace web frameworks and the design principles that they afford. Moreover, as graduation approaches, studying this subject should be good preparation for entering the web development industry.






%%%%%%%%%%%%%%%%%%%%%%%%%

% ~15 pages

% 1. A Creative and Descriptive Title
% 2. Abstract
% 3. Literature Review or Introduction
% 4. Methodology - what you did for yourself (in addition to the literature review)
% 5. The results - your analysis - the meat of your report
% 6. A conclusion which gracefully ends the whole paper

%%%%%%%%%%%%%%%%%%%%%%%%%




\newpage

\appendix
\section{Code Listings}
\label{app:code}

\subsection*{Pure JavaScript}

\lstinputlisting[style=html,caption={index.html},label={lst:pureHTML}]{../examples/pure-js/index.html}
\lstinputlisting[style=js,caption={app.js},label={lst:pureJS}]{../examples/pure-js/app.js}

\newpage

\subsection*{Angular}

\lstinputlisting[style=html,caption={index.html},label={lst:angularHTML}]{../examples/angular/index.html}
\lstinputlisting[style=js,caption={app.js},label={lst:angularJS}]{../examples/angular/app.js}

\newpage

\subsection*{React}

\lstinputlisting[style=html,caption={index.html},label={lst:reactHTML}]{../examples/react/index.html}
\lstinputlisting[style=js,caption={app.js},label={lst:reactJS}]{../examples/react/app.js}

\newpage

% BIBLIOGRAPHY (Note: We use a special version of IEEEtran that has sorting and annotations)
\begin{flushleft}
\begin{singlespace*}
	\bibliographystyle{./IEEEtran}
	\bibliography{angular-vs-react}
\end{singlespace*}
\end{flushleft}

\end{document}
